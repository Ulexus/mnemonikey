package main

import (
	"bytes"
	"crypto/rand"
	"flag"
	"fmt"
	"io"
	"strconv"
	"strings"
	"time"

	"github.com/kklash/mnemonikey"
	"golang.org/x/crypto/openpgp/armor"
)

var DefaultName = "anonymous"

type GenerateOptions struct {
	Name  string
	Email string
}

var GenerateCommand = &Command[GenerateOptions]{
	Name: "mnemonikey generate",
	AddFlags: func(flags *flag.FlagSet, opts *GenerateOptions) {
		flags.StringVar(&opts.Name, "name", DefaultName, "Display name for the PGP key user identifier.")
		flags.StringVar(&opts.Email, "email", "", "Email for the PGP key user identifier. (optional)")
	},
	Execute: func(opts *GenerateOptions, args []string) error {
		return generateAndPrintKey(opts.Name, opts.Email)
	},
}

func generateAndPrintKey(name, email string) error {
	name = strings.TrimSpace(name)
	email = strings.TrimSpace(email)

	seed := make([]byte, 16)
	if _, err := io.ReadFull(rand.Reader, seed); err != nil {
		return fmt.Errorf("failed to read secure random seed data: %w", err)
	}

	birthday := time.Now()

	keyPair, err := mnemonikey.NewDeterministicKeyPair(seed, name, email, birthday, time.Time{})
	if err != nil {
		return err
	}

	if err != nil {
		return err
	}

	pgpArmorKey, err := keyPair.EncodePGPArmor([]byte(nil))
	if err != nil {
		return err
	}

	recoveryMnemonic, err := keyPair.EncodeMnemonic()
	if err != nil {
		return err
	}

	fmt.Printf("Generated OpenPGP private key:\n\n%s\n\n", pgpArmorKey)

	// TODO print debug info about key
	// TODO print in color

	fmt.Printf("This is the key mnemonic which can be used to deterministically recover the private key:\n\n")
	printMnemonic(recoveryMnemonic)
	fmt.Printf("\nSave this phrase in a secure place, preferably offline on paper.\n\n")

	fmt.Printf(
		"You should also save the name and email address used to create the key. " +
			"If you later try to recover the key with the same mnemonic phrase but " +
			"a different name or email, it will derive the same key, but with a different " +
			"key identifier. To anyone verifying signatures using the old public key, " +
			"signature generated by the recovered key will not verify correctly\n\n",
	)

	fmt.Printf("Name:  %q\n", name)
	fmt.Printf("Email: %q\n", email)

	return nil
}

func armorEncode(blockType string, data []byte) (string, error) {
	buf := new(bytes.Buffer)
	armorWriter, err := armor.Encode(buf, blockType, nil)
	if err != nil {
		return "", fmt.Errorf("failed to construct armor encoder: %w", err)
	}
	if _, err := armorWriter.Write(data); err != nil {
		return "", fmt.Errorf("failed to write PGP packets to armor encoder: %w", err)
	}
	if err := armorWriter.Close(); err != nil {
		return "", fmt.Errorf("failed to close PGP armor encoder: %w", err)
	}
	return buf.String(), nil
}

func printMnemonic(words []string) {
	for i, word := range words {
		humanIndex := strconv.Itoa(i + 1)
		spacing := strings.Repeat(" ", 4-len(humanIndex))
		fmt.Printf("%s:%s%s\n", humanIndex, spacing, word)
	}
}
