package mnemonikey

import (
	"bytes"
	"errors"
	"fmt"
	"hash/crc32"
	"math/big"
	"time"

	"github.com/kklash/mnemonikey/mnemonic"
	"github.com/kklash/mnemonikey/pgp"
	"golang.org/x/crypto/openpgp"
	"golang.org/x/crypto/openpgp/armor"
)

// EpochIncrement is the level of granularity available for the creation date of
// keys generated by mnemonikey.
const EpochIncrement = time.Second

// ChecksumGenerator is the generator polynomial used to calculate a cyclic redundancy
// checksum (CRC) of the recovery payload.
const ChecksumGenerator uint32 = crc32.IEEE

// EpochStart is the start of the epoch after which key creation times are encoded
// in recovery phrases. It is exactly midnight in UTC time on the new year's eve
// between 2021 and 2022.
//
// In unix time, this epoch is exactly 1640995200 seconds after the unix epoch.
var EpochStart = time.Date(2022, 1, 1, 0, 0, 0, 0, time.UTC)

// checksumTable is the precomputed table used to create checksums of backup payloads.
var checksumTable = crc32.MakeTable(ChecksumGenerator)

const (
	// CreationOffsetBitCount is the number of bits used to represent a key creation offset.
	CreationOffsetBitCount uint = 31

	// ChecksumBitCount is the number of bits in the backup payload reserved for the checksum.
	ChecksumBitCount uint = 6

	// EntropyBitCount is the number of bits of entropy in the seed used to derive PGP keys.
	EntropyBitCount = 128

	// MnemonicSize is the number of mnemonic words needed to encode
	// both the key creation offset and 128 bits of seed entropy.
	MnemonicSize uint = 15
)

const checksumMask = (1 << ChecksumBitCount) - 1

// MaxCreationTime is the farthest point in the future that the mnemonikey recovery phrase
// encoding algorithm can represent key creation timestamps for.
var MaxCreationTime = EpochStart.Add(EpochIncrement * (time.Duration(1<<CreationOffsetBitCount) - 1))

var (
	// ErrExpiryTooEarly is returned when constructing a DeterministicKeyPair, if its creation
	// and expiry times are conflicting.
	ErrExpiryTooEarly = errors.New("expiry time predates key creation offset")

	// ErrCreationTooLate is returned when constructing a DeterministicKeyPair, if its creation
	// time is too far in the future to fit in CreationOffsetBitCount.
	ErrCreationTooLate = errors.New("key creation time exceeds maximum")

	// ErrCreationTooEarly is returned when constructing a DeterministicKeyPair, if its creation
	// time is before EpochStart.
	ErrCreationTooEarly = errors.New("key creation time exceeds maximum")
)

// DeterministicKeyPair represents a determinstically generated PGP key pair. It contains
// a master certification key, and encryption, authentication, and signing subkeys, as well
// as the seed data used to derive all four keys.
type DeterministicKeyPair struct {
	pgpKeyPair      *pgp.KeyPair
	seed            *Seed
	keyCreationTime time.Time
	creationOffset  uint32
}

// NewDeterministicKeyPair constructs a DeterministicKeyPair from a seed.
//
// The key creation timestamp is hashed when computing the PGP public key fingerprint,
// and thus is critical to ensuring deterministic key re-generation. This function rounds
// the creation time down to the most recent EpochIncrement before creation, so that it can
// be encoded into a recovery mnemonic.
//
// The user ID parameters, name and email, are not required but are highly recommended
// to assist in identifying the key later.
func NewDeterministicKeyPair(
	seed *Seed,
	name string,
	email string,
	creation time.Time,
	expiry time.Time,
) (*DeterministicKeyPair, error) {
	userID := &pgp.UserID{
		Name:  name,
		Email: email,
	}

	if !expiry.IsZero() && creation.After(expiry) {
		return nil, ErrExpiryTooEarly
	}
	if creation.After(MaxCreationTime) {
		return nil, ErrCreationTooLate
	}

	creationOffset := creation.Sub(EpochStart) / EpochIncrement
	if creationOffset < 0 {
		return nil, ErrCreationTooEarly
	}

	pgpKeyPair, err := pgp.NewKeyPair(seed.Bytes(), userID, creation, expiry)
	if err != nil {
		return nil, err
	}

	keyPair := &DeterministicKeyPair{
		pgpKeyPair:      pgpKeyPair,
		seed:            seed,
		keyCreationTime: creation,
		creationOffset:  uint32(creationOffset),
	}

	return keyPair, nil
}

// CreatedAt returns the key creation date, rounded to an EpochIncrement
// after the EpochStart date.
func (keyPair *DeterministicKeyPair) CreatedAt() time.Time {
	return keyPair.keyCreationTime
}

// FingerprintV4 returns the SHA1 hash of the master key and the key user ID.
func (keyPair *DeterministicKeyPair) FingerprintV4() []byte {
	return keyPair.pgpKeyPair.MasterKey.FingerprintV4()
}

// EncodePGP encodes the key pair as a series of binary OpenPGP packets.
func (keyPair *DeterministicKeyPair) EncodePGP(password []byte) ([]byte, error) {
	return keyPair.pgpKeyPair.EncodePackets(password)
}

// EncodePGP encodes the key pair as a series of OpenPGP packets and formats
// them an ASCII armor block format.
func (keyPair *DeterministicKeyPair) EncodePGPArmor(password []byte) (string, error) {
	keyPacketData, err := keyPair.pgpKeyPair.EncodePackets(password)
	if err != nil {
		return "", err
	}
	pgpArmorKey, err := armorEncode(openpgp.PrivateKeyType, keyPacketData)
	if err != nil {
		return "", err
	}
	return pgpArmorKey, nil
}

// EncodeMnemonic encodes the key pair's seed and creation offset into an English recovery
// mnemonic. The recovery mnemonic alone is sufficient to recover the entire key pair.
func (keyPair *DeterministicKeyPair) EncodeMnemonic() ([]string, error) {
	payloadInt := new(big.Int).Set(keyPair.seed.Value)
	payloadInt.Lsh(payloadInt, CreationOffsetBitCount)
	payloadInt.Or(payloadInt, big.NewInt(int64(keyPair.creationOffset)))

	payloadBitCount := EntropyBitCount + CreationOffsetBitCount
	payloadBytes := payloadInt.FillBytes(make([]byte, (payloadBitCount+7)/8))

	checksum := checksumMask & crc32.Checksum(payloadBytes, checksumTable)
	payloadInt.Lsh(payloadInt, ChecksumBitCount)
	payloadInt.Or(payloadInt, big.NewInt(int64(checksum)))

	indices := mnemonic.EncodeToIndices(payloadInt, payloadBitCount+ChecksumBitCount)
	words, err := mnemonic.EncodeToMnemonic(indices)
	if err != nil {
		return nil, fmt.Errorf("failed to encode indices to words: %w", err)
	}
	return words, nil
}

func armorEncode(blockType string, data []byte) (string, error) {
	buf := new(bytes.Buffer)
	armorWriter, err := armor.Encode(buf, blockType, nil)
	if err != nil {
		return "", fmt.Errorf("failed to construct armor encoder: %w", err)
	}
	if _, err := armorWriter.Write(data); err != nil {
		return "", fmt.Errorf("failed to write PGP packets to armor encoder: %w", err)
	}
	if err := armorWriter.Close(); err != nil {
		return "", fmt.Errorf("failed to close PGP armor encoder: %w", err)
	}
	return buf.String(), nil
}
